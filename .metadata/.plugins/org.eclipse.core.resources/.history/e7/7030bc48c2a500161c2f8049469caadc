import java.awt.Point;

import javax.net.ssl.ExtendedSSLSession;

/*
 * public int getPlayer() 
 * 
 * public int getBaordStatus(int r, int c)
 * 
 * public int getWinner()
 * 
 * public void reset() ---- restart the game
 * 
 * public void move(int r, int c) ---- put a chess piece
 * 
 * 
 * public int QScore(int r, int c, int player) ---- count score after trying to put a chess piece on (r, c)
 * 
 **/

public class ChessBoard implements Cloneable {

	// Constant
	public static final int EMPTY = 0; // The cell is empty.
	public static final int BLACK = 1;
	public static final int WHITE = 2;

	public static final int FIVE = 10000;
	public static final int MORE_FOUR = 10000;
	public static final int FOUR = 1000;
	public static final int H_FOUR = 2000;
	public static final int THREE = 100;
	public static final int H_THREE = 1000;
	public static final int TWO = 10;
	public static final int LOSE = -1000000;

	public int maxRow = 15;
	public int maxCol = 15;
	private ChessType[][] board;
	private ChessType player;
	private ChessType isWin;
	private int moves;

	ChessBoard(int rows, int cols) {
		maxRow = rows;
		maxCol = cols;
		board = new ChessType[maxRow][maxCol];
		reset();
	}

	ChessBoard() {
		board = new ChessType[maxRow][maxCol];
		reset();
	}

	public ChessType getPlayer() {

		return player;
	}

	public ChessType getBoardStatus(int r, int c) {
		assert r >= 0 && r <= maxCol && c >= 0 && c <= maxCol;
		return board[r][c];
	}

	public ChessType getWinner() {
		return isWin;
	}

	public void reset() {
		for (int r = 0; r < maxRow; r++) {
			for (int c = 0; c < maxCol; c++) {
				board[r][c] = ChessType.EMPTY;
			}
		}
		moves = 0; // No moves so far.
		isWin = ChessType.EMPTY; // So far no winner
		player = ChessType.BLACK;
	}

	public int move(int r, int c, ChessType chessType) {
		assert board[r][c] == ChessType.EMPTY; // make sure (r, c) is empty
		board[r][c] = chessType; // Record this move.

		return QScore(r, c, chessType);

	}

	public int move(Point point, ChessType chessType) {

		return move(point.x, point.y, chessType);

	}

	// public void move(int r, int c) {
	// assert board[r][c] == ChessType.EMPTY; //make sure (r, c) is empty
	// board[r][c] = player; // Record this move.
	// player = ChessType.nextType(player); // Flip players
	// moves++; // Increment number of moves.
	// }

	public int QScore(int r, int c, ChessType player) {
		MyScore tmpScore = new MyScore();
		MyScore score = new MyScore();
		// m, n are attack and defense ratio
		int m = 1;
		int n = 1;
		assert board[r][c] == ChessType.EMPTY; // make sure (r, c) is empty
		// board[r][c] = player; //put player on the position to make
		// calculation
		for (int row = 0; row < maxRow; row++) {
			for (int col = 0; col < maxCol; col++) {
				// look at 4 kinds of direction
				// 1. a column going up
				// 2. a row going to the right
				// 3. a diagonal up and to the right
				// 4. a diagonal up and to the left
				if (row < maxRow - 4) {// Look up
					tmpScore = countScore(row, 1, col, 0, player);
					score.refresh(tmpScore);
				}

				if (col < maxCol - 4) { // row to right
					tmpScore = countScore(row, 0, col, 1, player);
					score.refresh(tmpScore);
					if (row < maxRow - 4) { // diagonal up to right
						tmpScore = countScore(row, 1, col, 1, player);
						score.refresh(tmpScore);
					}
				}

				if (col > 3 && row < maxRow - 4) { // diagonal up left
					tmpScore = countScore(row, 1, col, -1, player);
					score.refresh(tmpScore);
				}

			}
		}

		return score.getScore();
	}

	private MyScore countScore(int r, int c, int dr, int dc, ChessType player) {
		MyScore tmpScore = new MyScore();
		int posCount = 1;
		int negCount = 1;
		int posFlag = 1;
		int negFlag = 1;
		int m = 1;
		int n = 1;

		/* count same ChessType */
		for (int i = 1; i < 5; i++) {
			if (board[r + dr * i][c + dc * i] != ChessType.nextType(player)
					&& posFlag == 1) {
				if (board[r + dr * i][c + dc * i] == player)
					posCount++;
			} else {
				posFlag = 0;
			}
			if (board[r + dr * i][c + dc * i] != player && negFlag == 1) {
				if (board[r + dr * i][c + dc * i] == player)
					negCount++;
			} else {
				negFlag = 0;
			}
		}

		/* count attackScore */
		if (posCount == 2) {
			tmpScore.a_two++;
		} else if (posCount == 3) {
			if (r - dr * 1 > 0 && c - dc * 1 > 0) {
				if (board[r - dr * 1][c - dc * 1] == ChessType.EMPTY) {
					tmpScore.a_h_three++;
				}
			} else if (r + dr * 5 < maxRow && c + dc * 5 < maxCol) {
				if (board[r + dr * 5][c + dc * 5] == ChessType.EMPTY) {
					tmpScore.a_h_three++;
				}
			} else {
				tmpScore.a_three++;
			}
		} else if (posCount == 4) {
			if (r - dr * 1 > 0 && c - dc * 1 > 0) {
				if (board[r - dr * 1][c - dc * 1] == ChessType.EMPTY) {
					tmpScore.a_h_four++;
				}
			} else if (r + dr * 5 < maxRow && c + dc * 5 < maxCol) {
				if (board[r + dr * 5][c + dc * 5] == ChessType.EMPTY) {
					tmpScore.a_h_four++;
				}
			} else {
				tmpScore.a_four++;
			}
		} else if (posCount == 5) {
			tmpScore.a_five++;
		}

		/* count negScore */
		if (negCount == 2) {
			tmpScore.d_two++;
		} else if (negCount == 3) {
			if (r - dr * 1 > 0 && c - dc * 1 > 0) {
				if (board[r - dr * 1][c - dc * 1] == ChessType.EMPTY) {
					tmpScore.d_h_three++;
				}
			} else if (r + dr * 5 < maxRow && c + dc * 5 < maxCol) {
				if (board[r + dr * 5][c + dc * 5] == ChessType.EMPTY) {
					tmpScore.d_h_three++;
				}
			} else {
				tmpScore.d_h_three++;
			}
		} else if (negCount == 4) {
			if (r - dr * 1 > 0 && c - dc * 1 > 0) {
				if (board[r - dr * 1][c - dc * 1] == ChessType.EMPTY) {
					tmpScore.d_h_four++;
				}
			} else if (r + dr * 5 < maxRow && c + dc * 5 < maxCol) {
				if (board[r + dr * 5][c + dc * 5] == ChessType.EMPTY) {
					tmpScore.d_h_four++;
				}
			} else {
				tmpScore.d_four++;
			}
		} else if (negCount == 5) {
			tmpScore.d_five++;
		}

		return tmpScore;
	}

	@Override
	public ChessBoard clone() {
		ChessBoard clonedChessboard = new ChessBoard();
		for (int row = 0; row < maxRow; ++row) {
			for (int column = 0; column < maxRow; ++column) {
				clonedChessboard.move(row, column, this.board[row][column]);
			}
		}
		return clonedChessboard;
	}
}

final class MyScore {
	int a_two;
	int d_two;
	int a_three;
	int d_three;
	int a_four;
	int d_four;
	int a_h_three;
	int d_h_three;
	int a_h_four;
	int d_h_four;
	int a_five;
	int d_five;

	public MyScore() {
		a_two = 0;
		d_two = 0;
		a_three = 0;
		d_three = 0;
		a_four = 0;
		d_four = 0;
		a_h_three = 0;
		d_h_three = 0;
		a_h_four = 0;
		d_h_four = 0;
		a_five = 0;
		d_five = 0;
	}
	public void refresh(MyScore ms){
		this.a_five += ms.a_five;
		this.d_five += ms.d_five;
		this.a_four += ms.a_four;
		this.d_four += ms.d_four;
		this.a_h_four += ms.a_h_four;
		this.d_h_four += ms.d_h_four;
		this.a_three += ms.a_three;
		this.d_three += ms.d_three;
		this.a_h_three += ms.a_h_three;
		this.d_h_three += ms.d_h_three;
		this.a_two += ms.a_two;
		this.d_two += ms.d_two;
		return;
	}
	
	
	public int getScore() {
		int pos = a_five*10000 + a_h_four*5000 + a_four*1000 + a_h_three*500 + a_three*100 + a_two*10;
		int neg = d_five*10000 + d_h_four*5000 + d_four*1000 + d_h_three*500 + d_three*100 + d_two*10;
		return pos-neg;
	}
}