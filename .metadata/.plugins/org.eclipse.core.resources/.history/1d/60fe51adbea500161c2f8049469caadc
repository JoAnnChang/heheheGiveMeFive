import java.awt.Point;

import javax.net.ssl.ExtendedSSLSession;

/*
 * public int getPlayer() 
 * 
 * public int getBaordStatus(int r, int c)
 * 
 * public int getWinner()
 * 
 * public void reset() ---- restart the game
 * 
 * public void move(int r, int c) ---- put a chess piece
 * 
 * 
 * public int QScore(int r, int c, int player) ---- count score after trying to put a chess piece on (r, c)
 * 
 **/



public class ChessBoard implements Cloneable{
	
	
	
	//Constant
	public static final int EMPTY   = 0;  // The cell is empty.
	public static final int BLACK = 1;
    public static final int WHITE = 2;
    
    
    
    public static final int FIVE = 10000;
    public static final int MORE_FOUR = 10000;
    public static final int FOUR = 1000;
    public static final int H_FOUR = 2000;
    public static final int THREE = 100;
    public static final int H_THREE = 1000;
    public static final int TWO = 10;
    public static final int LOSE = -1000000;
    
    
    
	
	public int maxRow = 15;
	public int maxCol = 15;
	private ChessType[][] board;
	private ChessType player;
	private ChessType isWin;
	private int moves;
	
	
	ChessBoard(int rows, int cols) {
		maxRow = rows;
        maxCol = cols;
        board = new ChessType[maxRow][maxCol];
        reset();
	}
	ChessBoard() {
		board = new ChessType[maxRow][maxCol];
        reset();
	}	
	
	public ChessType getPlayer() {
		
		return player;
	}
	

	public ChessType getBoardStatus(int r, int c) {
		assert r >= 0 && r<=maxCol && c>=0 && c<=maxCol;
		return board[r][c];
	}
	
	public ChessType getWinner(){
		return isWin;
	}

    public void reset() {
        for (int r=0; r<maxRow; r++) {
            for (int c=0; c<maxCol; c++) {
                board[r][c] = ChessType.EMPTY;
            }
        }
        moves = 0;  // No moves so far.
        isWin = ChessType.EMPTY;	// So far no winner
        player = ChessType.BLACK;  
    }
    
    public int move(int r, int c, ChessType chessType) {
        assert board[r][c] == ChessType.EMPTY;	//make sure (r, c) is empty
        board[r][c] = chessType;  	// Record this move.
        
        return QScore(r, c, chessType);

    }
    
    public int move(Point point, ChessType chessType) {
 
        return move(point.x, point.y, chessType);

    }
//    public void move(int r, int c) {
//        assert board[r][c] == ChessType.EMPTY;	//make sure (r, c) is empty
//        board[r][c] = player;  	// Record this move.
//        player = ChessType.nextType(player); 	// Flip players
//        moves++;                  // Increment number of moves.
//    }
    
    public int QScore(int r, int c, ChessType player) {
    	MyScore tmpScore = new MyScore(0,0);
    	int attackScore = 0;
    	int defenseScore = 0;
    	int m = 1;
    	int n = 1;
    	assert board[r][c] == ChessType.EMPTY;	//make sure (r, c) is empty
    	//board[r][c] = player;	//put player on the position to make calculation
    	for (int row = 0; row < maxRow; row++) {
    		for (int col = 0; col < maxCol; col++) {
    			ChessType p = board[row][col];
    			if (p != ChessType.EMPTY) {
                // look at 4 kinds of direction
                //  1. a column going up
                //  2. a row going to the right
                //  3. a diagonal up and to the right
                //  4. a diagonal up and to the left

    				if (row < maxRow-4) {// Look up
    					tmpScore = countScore(row, 1, col, 0, player);
    					attackScore += tmpScore.posScore;
    					defenseScore += tmpScore.negScore;
    				}

    				if (col < maxCol-4) { // row to right
    					tmpScore = countScore(row, 0, col, 1, player);
    					attackScore += tmpScore.posScore;
    					defenseScore += tmpScore.negScore;
    					if (row < maxRow-4) { // diagonal up to right
    						tmpScore = countScore(row, 1, col, 1, player);
    						attackScore += tmpScore.posScore;
        					defenseScore += tmpScore.negScore;
    					}
    				}

    				if (col > 3 && row < maxRow-4) { // diagonal up left
    					tmpScore = countScore(row, 1, col, -1, player);
    					attackScore += tmpScore.posScore;
    					defenseScore += tmpScore.negScore;
    				}
    			}
    		}
    	}
    	
    	
    	return m*score.posScore-n*score.negScore;
    }
    
    
    private MyScore countScore(int r, int c, int dr, int dc, ChessType player) {
    	MyScore tmpScore = new MyScore();
    	int posCount = 1;
    	int negCount = 1;
    	int posFlag = 1;
    	int negFlag = 1;
    	int m=1;
    	int n=1;
    	
    	/*count same ChessType*/
        for (int i=1; i<5; i++) {
        	if(board[r+dr*i][c+dc*i] != ChessType.nextType(player) && posFlag==1) {
        		if(board[r+dr*i][c+dc*i] == player)	posCount++;
        	}
        	else {
        		posFlag = 0;
        	}
        	if(board[r+dr*i][c+dc*i] != player && negFlag==1) {
        		if(board[r+dr*i][c+dc*i] == player)	negCount++;
        	}
        	else {
        		negFlag = 0;
        	}
        }
        
        /*count posScore*/
        if(posCount == 2)	{
        	tmpScore.posScore += TWO;
        }
        else if(posCount == 3)	{
        	if(r-dr*1>0 && c-dc*1>0){
        		if(board[r-dr*1][c-dc*1] == ChessType.EMPTY) {
        			tmpScore.posScore += H_THREE; 
        		}
        	}
        	else if (r+dr*5<maxRow && c+dc*5<maxCol) {
        		if(board[r+dr*5][c+dc*5] == ChessType.EMPTY) {
        			tmpScore.posScore += H_THREE;
        		}
        	}
        	else {
        		tmpScore.posScore += THREE;
        	}
        }
        else if(posCount == 4){
        	if(r-dr*1>0 && c-dc*1>0){
        		if(board[r-dr*1][c-dc*1] == ChessType.EMPTY) {
        			tmpScore.posScore += H_FOUR;
        		}
        	}
        	else if (r+dr*5<maxRow && c+dc*5<maxCol) {
        		if(board[r+dr*5][c+dc*5] == ChessType.EMPTY) {
        			tmpScore.posScore += H_FOUR;
        		}
        	}
        	else {
        		tmpScore.posScore += FOUR;
        	}
        }
        else if(posCount==5) {
        	tmpScore.posScore += FIVE;
        }
        
        /*count negScore*/
        if(negCount == 2)	{
        	tmpScore.negScore += TWO;
        }
        else if(negCount == 3)	{
        	if(r-dr*1>0 && c-dc*1>0){
        		if(board[r-dr*1][c-dc*1] == ChessType.EMPTY) {
        			tmpScore.negScore += H_THREE; 
        		}
        	}
        	else if (r+dr*5<maxRow && c+dc*5<maxCol) {
        		if(board[r+dr*5][c+dc*5] == ChessType.EMPTY) {
        			tmpScore.negScore += H_THREE;
        		}
        	}
        	else {
        		tmpScore.negScore += THREE;
        	}
        }
        else if(negCount == 4){
        	if(r-dr*1>0 && c-dc*1>0){
        		if(board[r-dr*1][c-dc*1] == ChessType.EMPTY) {
        			tmpScore.negScore += H_FOUR;
        		}
        	}
        	else if (r+dr*5<maxRow && c+dc*5<maxCol) {
        		if(board[r+dr*5][c+dc*5] == ChessType.EMPTY) {
        			tmpScore.negScore += H_FOUR;
        		}
        	}
        	else {
        		tmpScore.negScore += FOUR;
        	}
        }
        else if(negCount==5) {
        	tmpScore.negScore += FIVE;
        }
        
        return tmpScore;
    }
    
    
    @Override
    public ChessBoard clone() {
    	ChessBoard clonedChessboard = new ChessBoard();
	for (int row = 0; row < maxRow; ++row) {
	    for (int column = 0; column < maxRow; ++column) {
	    	clonedChessboard.move(row, column, this.board[row][column]);
	    }
	}
	return clonedChessboard;
    }
}


final class MyScore {
    int posScore;
    int negScore;

    public MyScore(int p, int n) {
        this.posScore = p;
        this.negScore = n;
    }
    
    public MyScore() {
        this.posScore = 0;
        this.negScore = 0;
    }

    public int getPos() {
        return posScore;
    }

    public int getNeg() {
        return negScore;
    }
}